# 树

#### 树的定义

1. 有且只有一个根节点
2. 有若干互不相交的子树，每个子树本身也是一颗树

**深度：** 从根节点到最底层的层数，根节点是第一层

#### 数的分类

- 一般树

  任意一个节点的个数不受限制

- 二叉树

  任意节点最多两个子节点，且子节点的位置不可变

  - 一般二叉树

  - 满二叉树

    不增加树的前提下，无法再添加节点，最后一层已满

  - **完全二叉树**

    删除满二叉树，最底层最右边的子节点则形成完全二叉树

    满二叉树是特殊的完全二叉树

- 森林

  n个互不相交的树的集合

#### 树的存储

- 二叉树的存数

  - 连续存数

    <img src="images\image-20200118174244166.png" alt="image-20200118174244166" style="zoom: 67%;" />

  二叉树本身是非线性的，但是底层采用数组这种线性结构存储时，树本身必须具备或人为创造为完全二叉树

  如果树本身不是完全二叉树，需要在数组相应位置插入虚拟节点

  否则无法保存整个树的关系

  常见的前序、后序、中序算法，就是将**链式存储**的完全二叉树转存为**连续存储**的数组

  **优点：** 查找（包括判断）某个节点的父节点、子节点效率高

  **缺点：**耗用内存较大，且不利于节点的增删

  - 链式存储

  普通的二叉树一般使用链式存储，每个节点分数据域+指针域（左节点、右节点指针）

  **优点：** 耗用内存小，利于增删节点

  **缺点：**寻找指定节点不方便 

- 一般树的存储

  - 双亲表示法

  - 孩子表示法

  - 双亲孩子表示法

  - 二叉树表示法

    - 将普通的树转化为二叉树来存储

      具体转化方法：

      设法保证任意一个节点

      左指针域指向他的第一个孩子

      右指针域指向他的下一个兄弟

#### 树的操作

##### 树的遍历

- 先序

  - **中**左右

    先访问根节点，再**左子树**，**再右子树**

- 中序

  - 左**中**右

    左子树+根+右子树

- 后序

  - 左右**中**

##### 已知两种遍历序列求原始二叉树

通过先序+中序、中序+后序可以还原原始的二叉树

但是通过先序+后序无法还原

例子： 

![image-20200118211515789](images\image-20200118211515789.png)

1. 先序遍历的第一位一定是根节点
2. 因此中序遍历被A分为两块，左子树BDCE
   1. 左子树BDCE在先序中先出现的是B，因此B为根，左子树空，右子树为DCE
      1. 右子树DCE中C在先序中先出现，因此C为根，D为左，E为右
3. 右子树FHG
   1. 右子树FHG中，F在先序中先出现，因此F为根，无左子树，右子树为HG
      1. 右子树HG在先序中先出现的是G，因此G为根，H为左子树

例子：

同理先知道后序+中序，一样进行类推，不同的是，以中序作为基础，判断左右子树的根节点时，顺序由右向左推

![image-20200118221337982](images\image-20200118221337982.png)

#### 树的应用

- 数据库中数据组织的重要形式
- 操作系统的父子进程的关系本身就是一颗树
- 面向对象的继承关系